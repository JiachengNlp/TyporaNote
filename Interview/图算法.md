# 图算法

##  基础知识





## 相关题目

##### 拓扑排序

输入一张图，按照依赖关系顺序打印，关键点是在队列里面存放入度为0的Node，并依次打印

1. 准备HashMap，key为Node，value为该点剩余入度值
2. 准备队列zeroInQueue，用于存放入度为0的Node
3. 准备ArrayList result，当队列不为空时，用于每次接受队列弹出的Node

 ```

```java
public static List<Node> sortedTopo(Graph graph) {
  HashMap<Node, Integer> inMap = new HashMap<>();
  Queue<Node> zeroInQueue = new LinkedList<>();
  
  for (Node node : graph.nodes.values()) {
    inMap.put(node, node.in);
    if (node.in == 0) {
      zeroInQueue.add(node);
    }
  }
  List<Node> Result = new ArrayList<>();
  // List属于Java重要结构，可以多种方式实现
  
  while (!zeroInQueue.isEmpty()) {
    Node cur = zeroInQueue.poll();
    result.add(cur);
    // 去除当前Node对其它Node入度的影响
    for (Node next : cur.nexts) {
      inMap.put(next, inMap.get(next) - 1);
      if (inMap.get(next) == 0) {
        zeroInQueue.add(next);
      }
    }
  }
  return result;
}
```



##### 最小生成树算法Krskal（有向图）

<img src="/Users/djc/Library/Application Support/typora-user-images/image-20210610115353287.png" alt="image-20210610115353287" style="zoom:50%;" />

核心是利用并查集合并需要联通的节点

1. 初始化一个并查集unionFind，使用makeSet、union、isSameSet等方法
2. 准备一个小根堆priorityQueue，以图的边权重排序
3. 构造一个比较器

```java
public static class EdgeComparator implements Comparator<Edge> {
  @Override
  public int compare(Edge o1, Edge o2) {
    return o1.weight - o2.weight;
  }
}

public static Set<Edge> Kruskal(Graph graph) {
  UnionFind unionfind = new UnionFind();
  PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
  // 初始化unionfind
  unionfind.makeSet(graph.nodes.value());
  // 把边加入小根堆内排好序
  for (Edge edge : graph.edges) {
    priorityQueue.add(edge);
  }
  // 初始化最后输出set
  Set<Edge> result = new HashSet<>();
  // 在堆上面遍历每条边，查看from 和 to 两个节点是否一个集合
  while (!priorityQueue.isEmpty()) {
    Edge edge = priorityQueue.poll();
    if (!unionFind.isSameSet(edge.from, edge.to)) {
      result.add(edge);
      unionFind.union(edge.from, edge.to);
    }
  }
  return result;
}
```



#####最小生成树算法P算法（有向图）

不需要并查集，随机选择一个Node，解锁对应Edge，并选择最小Edge后重复操作

1. 准备一个小根堆priorityQueue
2. 准备HashSet edgeSet，用于存放已经考虑过的edge集合
3. 准备HashSet nodeSet，用于存放已经考虑过的node集合
4. 准备HashSet result，用于顺序存放最终输出edge集合
5. 随机选择一个Node，如Node不在nodeSet中，则nodeSet.add(Node)
6. 遍历Node所有边集合edges，edge不在edgeSet中，则把edge加入priorityQueue中
7. 不断弹出堆顶最小edge，如edge连接node是不在nodeSet中，则加入，该edge加入result中
8. 遍历该node所有边edge，重复6